## 정리하기 파일

# 9장. 모던 리액트 개발 도구로 개발 및 배포 환경 구축하기

## 도커란

### 도커용어

- 이미지
  - 도커에서 이미지란 컨테이너를 만드는 데 사용되는 템플릿을 의미한다. 이 이미지를 만들기 위해서는 Dockerfile이 필요하며, 이 파일을 빌드하면 이미지를 만들 수 있다.
- 컨테이너
  - 도커의 이미지를 실행한 상태를 컨테이너라고 한다. 이 컨테이너가 바로 독립된 공간이며, 이미지가 목표하는 운영체제, 파일 시스템, 각종 자원 및 네트워크 등이 할당되어 실행될 수 있는 독립된 공간이 생성된다.
- Dockerfile
  - 어떤 이미지 파일을 만들지 정의하는 파일이다. 이 파일을 빌드하면 이미지를 만들 수 있으며, 흔히 도커 이미지화한다(dockerize)라고 할 때 가장 먼저 하는 것이 바로 이 Dockerfile을 만드는 것이다.
- 태그
  - 이미지를 식별할 수 있는 레이블 값을 의미한다. 일반적으로 이름: 태그명 형태로 구성돼 있다. 대표적인 이미지인 ubuntu: latest를 예로 들면 ubuntu는 이미지 이름이고 latest는 태그명이다. 즉, ubunut: latest는 ubuntu의 latest인 이미지를 의미한다.
- 리포지터리
  - 이미지를 모아두는 저장소로, 앞서 언급했던 이름에 다양한 태그로 지정된 이미지가 모여있는 저장소다.
- 레지스트리
  - 리포지터리에 접근할 수 있게 해주는 서비스를 의미한다. 대표적인 레지스트리로는 도커 서브(Docker Hub)가 있다. 이 레지스트리에는 다양한 리포지터리가 있으며, 이 리포지터리에서 사용자는 자신이 원하는 이미지를 내려받아 사용할 수 있다.

### 자주 쓰는 도커 cli 명령어

- docker build
  - Dockerfile을 기준으로 이미지를 빌드하는 작업을 말한다.
- docker push
  - 이미지나 리포지터리를 도커 레지스트리에 업로드하는 과정을 의미한다.
- docker tag
  - 이미지에 태그를 생성하는 명령어다.
- docker inspect
  - 이미지나 컨테이너의 세부 정보를 출력하는 명령어다.
- docker run
  - 이미지를 기반으로 새로운 컨테이너를 생성하는 명렁어다.
- docker ps
  - 현재 가동 중인 컨테이너 목록을 확인할 수 있는 명령어다.
- docker rm
  - docker rm {이미지명} 으로 컨테이너를 삭제할 수 있다.

### Dockerfile 작성하기

```tsx
FROM node: 18.12.0-alpine3.16 as build

WORKDIR /app

COPY package.json ./package.json
COPY package-lock.json ./package-lock.json

RUN npm ci

COPY . ./

RUN npm run build
```

- FROM node: 18.12.0-alpine3.16 as build
  - 이 이미지가 어떤 베이스 이미지에서 실행될지를 결정한다. 여기서 사용한 베이스 이미지는 `node: 18.12.0-alpine3.16` 이다. node: 18.12.0이란 Node.js 18.12.0 버전이 설치돼 있는 이미지를 의미하며 alpine3.16은 이 이미지가 alpine 3.16 버전의 운영체제 위에서 실행되는 이미지라는 것을 의미한다. as build란 이 베이스 이미지를 build라고 하는 단계(스테이지)에서만 쓰겠다는 것을 의미한다.
- WORKDIR /app
  - WORKDIR이란 작업을 수행하고자 하는 기본 디렉터리를 의미한다.
- COPY
  - COPY는 파일을 복사하는 명령어다. 여기서는 package.json과 package-lock.json을 각각 ./package.json과 ./package-lock.json으로 복사하는데, 복사하는 위치는 앞서 설정한 기본 디렉터리, 즉 ./app이 된다.
- RUN npm ci
  - RUN을 실행하면 컨테이너에서 명령어를 실행할 수 있다.
- COPY . ./
  - 의존성을 설치했으니 이제 빌드만 남았다. 빌드를 위해서는 src, node_modules 등 대부분의 리소스가 필요하므로 COPY . ./ 으로 모든 리소스를 복사한다.
- RUN npm run build
  - 빌드에 필요한 리소스를 복사했으므로 빌드 명령어를 통해 애플리케이션을 빌드한다.

우리가 원하는 것은 Node.js가 실행되고 애플리케이션이 빌드되는 것이 아니라 애플리케이션이 실행되는 것이다. 이를 위해서는 다음과 같은 작업을 추가해야 한다.

1. 빌드된 웹 애플리케이션을 NGINX가 서비스할 수 있도록 설정한다.
2. 이미지를 실행했을 때 해당 웹페이지에 접근할 수 있어야 한다.
3. 웹페이지 접근에 필요한 빌드 파일만 남겨두고 용량을 최소화한다.

```tsx
FROM nginx: 1.23.2-alpine as start

COPY ./nginx/nginx.conf /etc/nginx/nginx.conf
COPY --from=build /app/build /usr/share/nginx/html

EXPOSE 3000

ENTRYPOINT ["nginx", "-g", "daemon off;"]
```

- FROM nginx: 1.23.2-alpine as start
  - 빌드된 정적 파일을 서비스하기 위해 최신 버전의 NGINX가 설치된 알파인 리눅스를 설치했다.
- COPY ./nginx/nginx.conf /etc/nginx/nginx.conf
  - 빌드한 파일을 NGINX가 서비스할 수 있도록 설정 파일을 복사한다.
- COPY --from=build /app/build /usr/share/nginx/html
  - 앞서 …as build로 선언한 단계를 의미한다. 즉, build라는 단계에서 복사해 오는데, 여기서 /app/build만 가져와 현재의 단계인 start의 원하는 위치인 /usr/share/nginx/html에 복사하는 것이다. 이로써 build 단계에서 필요한 리소스만 가져와 start 단계에서 사용할 수 있게 된다.
- EXPOSE 3000
  - EXPOSE로 열어준 포트는 나중에 도커 이미지를 실행할 때 호스트 운영체제에서 오픈된다. 이미지를 만드는 사람이 해당 이미지를 컨테이너로 실행할 때 어떤 포트가 열려 있는지를 알려주는 용도
- ENTRYPOINT
  - 컨테이너가 시작됐을 때 어떤 명령을 실행할지 결정한다. 이는 Dockerfile 내부에서 단 한 번 실행할 수 있으며, 여기서는 NGINX의 데몬을 시작하도록 만들었다.
